using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using AutoMapper;
using CoreLayer.Models;
using CoreLayer.Services;
using ServiceLayer;
using Microsoft.AspNetCore.Mvc;
using PosTerminalApi.Resources;
using PosTerminalApi.Validators;

namespace PosTerminalApi.Controllers
{
    
    [Route("api/[controller]")]
    [ApiController]
    public class OrdersController : ControllerBase
    {
        private readonly IOrderService _orderService;
        private readonly IProductService _productService;
        private readonly IMapper _mapper;
        public OrdersController(IProductService productService,IOrderService orderService, IMapper mapper)
        {
            this._orderService = orderService;
            this._productService = productService;
            this._mapper = mapper;
        }
        /// <summary>
        /// Retrieves all Orders detail
        /// </summary>
        [HttpGet("")]
        public async Task<ActionResult<IEnumerable<Order>>> GetAllOrders()
        {
            var orders = await _orderService.GetAllWithOrder();
            var orderResources = _mapper.Map<IEnumerable<Order>, IEnumerable<OrderResource>>(orders);
            return Ok(orderResources);
        }
        /// <summary>
        /// Retrieves a specific order detail
        /// </summary>
        /// <remarks>
        /// Note that the key is the Id of the order.
        ///  
        ///     GET 
        ///     {
        ///        "Id": 1,
        ///     }
        /// 
        /// </remarks>
        /// <returns>Selected order</returns>
        [HttpGet("{id}")]
        public async Task<ActionResult<OrderResource>> GetOrderById(int id)
        {
            var order = await _orderService.GetOrderById(id);
            var orderResource = _mapper.Map<Order, OrderResource>(order);

            return Ok(orderResource);
        }
        /// <summary>
        /// Create an Order 
        /// </summary>
        /// <remarks>
        /// Note that the key is the Id of the Order which generated by the system automatically
        ///  
        ///     POST 
        ///     {
        ///             "id": 0,
        ///             "Amount": "0",
        ///             "Date": "",
        ///             "OrderedProducts": "A,B,C,D,A,B,A",
        ///     }
        /// 
        /// </remarks>
        /// <returns>New created order</returns>
        [HttpPost("")]
        public async Task<ActionResult<OrderResource>> CreateOrder([FromBody] SaveOrderResource saveOrderResource)
        {
            var validator = new SaveOrderResourceValidator();
            var validationResult = await validator.ValidateAsync(saveOrderResource);

            if (!validationResult.IsValid)
                return BadRequest(validationResult.Errors); 
            
            var orderToCreate = _mapper.Map<SaveOrderResource, Order>(saveOrderResource);
            var terminal = new PosTerminal(_productService);
            orderToCreate.Amount = await terminal.GenerateOrderAsync(orderToCreate.OrderedProducts);
            orderToCreate.Date = DateTime.Now;
            var newOrder = await _orderService.CreateOrder(orderToCreate);
            var order = await _orderService.GetOrderById(newOrder.Id);
            var orderResource = _mapper.Map<Order, OrderResource>(order);
            
            return Ok(orderResource);
        }
        /// <summary>
        /// Deletes a specific order 
        /// </summary>
        /// <remarks>
        /// Note that the key is the Id of the Order.
        ///  
        ///     DELETE 
        ///     {
        ///           "id": 1,
        ///     }
        /// 
        /// </remarks>
        /// <returns>Deleted existing order</returns>
        [HttpDelete("{id}")]
        public async Task<IActionResult> DeleteOrder(int id)
        {
            if (id == 0)
                return BadRequest();

            var order = await _orderService.GetOrderById(id);

            if (order == null)
                return NotFound();

            await _orderService.DeleteOrder(order);

            return NoContent();
        }
    }
}